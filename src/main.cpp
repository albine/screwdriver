#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <cstring>
#include <cstdlib>
#include <map>
#include <memory>
#include <algorithm>
#include <csignal>
#include <atomic>

// 引入策略引擎和适配器
#include "strategy_engine.h"
#include "backtest_adapter.h"
#include "live_market_adapter.h"

// 引入策略
#include "strategy/BreakoutPriceVolumeStrategy.h"
#include "strategy/BreakoutPriceVolumeStrategy_v2.h"
#include "strategy/OpeningRangeBreakoutStrategy.h"
#include "strategy/HenggouStrategy.h"
#include "strategy/PercentageGainBreakoutStrategy.h"
#include "strategy/TestOrderbookStrategy.h"

// 引入配置和策略工厂
#include "backtest_config.h"
#include "strategy_factory.h"
#include "strategy_ids.h"
#include "strategy_context.h"

// 引入持久化层
#include "persist_layer.h"

// 引入日志模块
#include "logger.h"

// 引入 ZMQ 通信模块
#include "zmq_client.h"

// 引入 fastfish SDK 所需头文件
#include "parameter_define.h"
#include "udp_client_interface.h"
#include "base_define.h"  // init_env() / fini_env()

// ==========================================
// 策略注册
// ==========================================
void register_all_strategies() {
    auto& factory = StrategyFactory::instance();

    // BreakoutPriceVolumeStrategy: 配置格式 "股票代码,BreakoutPriceVolumeStrategy,突破价格"
    // 突破价格从 params 获取（整数格式，如 98500 表示 9.85 元）
    factory.register_strategy("BreakoutPriceVolumeStrategy",
        [](const std::string& symbol, const std::string& params) -> std::unique_ptr<Strategy> {
            uint32_t breakout_price = 0;
            if (!params.empty()) {
                breakout_price = static_cast<uint32_t>(std::stoul(params));
            }
            auto strat = std::make_unique<BreakoutPriceVolumeStrategy>(symbol + "_Breakout", symbol, breakout_price);
            strat->strategy_type_id = StrategyIds::BREAKOUT_PRICE_VOLUME;
            return strat;
        });

    // BreakoutPriceVolumeStrategy_v2: 配置格式 "股票代码,BreakoutPriceVolumeStrategy_v2,突破价格"
    // 使用 OrderBook 快照获取挂单量（不依赖 FastOrderBook）
    factory.register_strategy("BreakoutPriceVolumeStrategy_v2",
        [](const std::string& symbol, const std::string& params) -> std::unique_ptr<Strategy> {
            uint32_t breakout_price = 0;
            if (!params.empty()) {
                breakout_price = static_cast<uint32_t>(std::stoul(params));
            }
            auto strat = std::make_unique<BreakoutPriceVolumeStrategy_v2>(symbol + "_Breakout_v2", symbol, breakout_price);
            strat->strategy_type_id = StrategyIds::BREAKOUT_PRICE_VOLUME_V2;
            return strat;
        });

    factory.register_strategy("OpeningRangeBreakoutStrategy",
        [](const std::string& symbol, const std::string& /*params*/) -> std::unique_ptr<Strategy> {
            auto strat = std::make_unique<OpeningRangeBreakoutStrategy>(symbol + "_ORB", symbol);
            strat->strategy_type_id = StrategyIds::OPENING_RANGE_BREAKOUT;
            return strat;
        });
    factory.register_strategy("PercentageGainBreakoutStrategy",
        [](const std::string& symbol, const std::string& /*params*/) -> std::unique_ptr<Strategy> {
            auto strat = std::make_unique<PercentageGainBreakoutStrategy>(symbol + "_PGB", symbol);
            strat->strategy_type_id = StrategyIds::PERCENTAGE_GAIN_BREAKOUT;
            return strat;
        });
    factory.register_strategy("TestOrderbookStrategy",
        [](const std::string& symbol, const std::string& params) -> std::unique_ptr<Strategy> {
            // 支持多个 applseqnum（逗号分隔）
            auto strat = std::make_unique<TestOrderbookStrategy>(symbol + "_TOS", symbol, params);
            strat->strategy_type_id = StrategyIds::TEST_ORDERBOOK;
            return strat;
        });

    // auto generated by add_strategy.py
    factory.register_strategy("HenggouStrategy",
        [](const std::string& symbol, const std::string& /*params*/) -> std::unique_ptr<Strategy> {
            auto strat = std::make_unique<HenggouStrategy>(symbol + "_HS", symbol);
            strat->strategy_type_id = StrategyIds::HENGGOU;
            return strat;
        });
}



// ==========================================
// 回测模式
// ==========================================
void run_backtest_mode(quill::Logger* logger, const std::string& config_file = "config/strategy_backtest.conf") {
    LOG_MODULE_INFO(logger, MOD_ENGINE, "=== Backtest Mode ===");

    // 注册所有策略
    register_all_strategies();

    // 解析配置文件
    auto configs = parse_strategy_config(config_file);
    if (configs.empty()) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "No valid configurations found in {}", config_file);
        LOG_MODULE_INFO(logger, MOD_ENGINE, "Config format: stock_code,strategy_name (e.g., 600759,BreakoutPriceVolumeStrategy)");
        return;
    }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Loaded {} backtest configurations from {}", configs.size(), config_file);

    // 加载引擎配置
    auto engine_cfg = parse_engine_config("config/engine.conf");

    // 创建策略引擎
    StrategyEngine engine;
    engine.set_interrupt_thresholds(
        engine_cfg.interrupt_threshold_strategy_ms,
        engine_cfg.interrupt_threshold_other_ms
    );

    // 有效股票列表（用于后续加载数据）
    std::vector<std::string> valid_symbols;

    auto& factory = StrategyFactory::instance();

    // 为每个配置创建策略并检查数据
    for (const auto& cfg : configs) {
        // 检查策略是否存在
        if (!factory.has_strategy(cfg.strategy_name)) {
            LOG_MODULE_WARNING(logger, MOD_ENGINE, "Unknown strategy: {}, skipping {}", cfg.strategy_name, cfg.symbol);
            auto available = factory.get_registered_strategies();
            std::string avail_str;
            for (const auto& s : available) avail_str += s + " ";
            LOG_MODULE_INFO(logger, MOD_ENGINE, "Available strategies: {}", avail_str);
            continue;
        }

        // 检查/下载数据
        if (!check_data_exists(cfg.symbol)) {
            LOG_MODULE_INFO(logger, MOD_ENGINE, "Data not found for {}, attempting download...", cfg.symbol);
            if (!download_market_data(cfg.symbol)) {
                LOG_MODULE_WARNING(logger, MOD_ENGINE, "Failed to download data for {}, skipping", cfg.symbol);
                continue;
            }
            if (!check_data_exists(cfg.symbol)) {
                LOG_MODULE_WARNING(logger, MOD_ENGINE, "Data still not available for {}, skipping", cfg.symbol);
                continue;
            }
            LOG_MODULE_INFO(logger, MOD_ENGINE, "Data downloaded successfully for {}", cfg.symbol);
        }

        // 创建策略实例并转移所有权给 engine
        try {
            auto strategy = factory.create(cfg.strategy_name, cfg.symbol, cfg.params);
            engine.register_strategy(cfg.symbol, std::move(strategy));  // 转移所有权
            valid_symbols.push_back(cfg.symbol);
        } catch (const std::exception& e) {
            LOG_MODULE_ERROR(logger, MOD_ENGINE, "Failed to create strategy for {}: {}", cfg.symbol, e.what());
        }
    }

    if (valid_symbols.empty()) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "No valid symbols to backtest");
        return;
    }

    // 创建回测上下文
    auto backtest_ctx = std::make_unique<BacktestContext>();

    // 为所有策略设置上下文
    engine.set_context_for_all_strategies(backtest_ctx.get());

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Starting strategy engine with {} symbols...", valid_symbols.size());
    engine.start();

    // 创建回测适配器
    BacktestAdapter adapter(&engine, engine.shard_count());

    // 为每个股票加载数据
    for (const auto& symbol : valid_symbols) {
        std::string tick_file = "test_data/MD_TICK_StockType_" + symbol + ".csv";
        std::string order_file = "test_data/MD_ORDER_StockType_" + symbol + ".csv";
        std::string txn_file = "test_data/MD_TRANSACTION_StockType_" + symbol + ".csv";

        LOG_MODULE_INFO(logger, MOD_ENGINE, "Loading data for {}...", symbol);

        if (!adapter.load_tick_file(tick_file)) {
            LOG_MODULE_WARNING(logger, MOD_ENGINE, "Failed to load TICK file for {}", symbol);
        }
        adapter.load_order_file(order_file);
        adapter.load_transaction_file(txn_file);

        LOG_MODULE_INFO(logger, MOD_ENGINE, "Total events after loading {}: {}", symbol, adapter.event_count());
    }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Replaying {} events...", adapter.event_count());
    adapter.replay();
    LOG_MODULE_INFO(logger, MOD_ENGINE, "Replay completed");

    // 等待队列排空
    std::this_thread::sleep_for(std::chrono::seconds(2));

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Stopping strategy engine...");
    engine.stop();
}

// ==========================================
// 全局 ZMQ 客户端
// ==========================================
static std::unique_ptr<ZmqClient> g_zmq_client;

// ==========================================
// 信号处理
// ==========================================
static std::atomic<bool> g_running{true};

static void signal_handler(int signum) {
    if (signum == SIGINT || signum == SIGTERM) {
        g_running.store(false, std::memory_order_relaxed);
    }
}

// ==========================================
// 实盘模式
// ==========================================
void run_live_mode(quill::Logger* logger,
                   const std::string& /*strategy_config_file*/ = "config/strategy_live.conf",
                   const std::string& engine_config_file = "config/engine.conf") {
    LOG_MODULE_INFO(logger, MOD_ENGINE, "=== Live Trading Mode ===");

    // 解析引擎配置
    auto engine_cfg = parse_engine_config(engine_config_file);
    LOG_MODULE_INFO(logger, MOD_ENGINE, "Loaded engine config from {}", engine_config_file);

    // 注册所有策略
    register_all_strategies();

    // 创建策略引擎
    StrategyEngine engine;
    engine.set_interrupt_thresholds(
        engine_cfg.interrupt_threshold_strategy_ms,
        engine_cfg.interrupt_threshold_other_ms
    );
    auto& factory = StrategyFactory::instance();

    // 有效股票列表（去重）
    std::vector<std::string> valid_symbols;
    // 记录每个 dealer 对应的 symbols
    std::vector<std::string> dealer1_symbols;
    std::vector<std::string> dealer2_symbols;

    // ========================================
    // 加载 DEALER1 的策略配置
    // ========================================
    auto configs1 = parse_strategy_config(engine_cfg.strategy_config_file);
    if (configs1.empty()) {
        LOG_MODULE_WARNING(logger, MOD_ENGINE, "No configurations found in {} (DEALER1)", engine_cfg.strategy_config_file);
    } else {
        LOG_MODULE_INFO(logger, MOD_ENGINE, "Loaded {} configurations from {} (DEALER1)", configs1.size(), engine_cfg.strategy_config_file);

        // 统计每种策略的配置数量
        std::map<std::string, int> strategy_counts;
        for (const auto& cfg : configs1) {
            strategy_counts[cfg.strategy_name]++;
        }
        for (const auto& [name, count] : strategy_counts) {
            LOG_MODULE_INFO(logger, MOD_ENGINE, "  DEALER1 - {}: {} symbols", name, count);
        }

        // 为每个配置创建策略
        for (const auto& cfg : configs1) {
            if (!factory.has_strategy(cfg.strategy_name)) {
                LOG_MODULE_WARNING(logger, MOD_ENGINE, "Unknown strategy: {}, skipping {}", cfg.strategy_name, cfg.symbol);
                auto available = factory.get_registered_strategies();
                std::string avail_str;
                for (const auto& s : available) avail_str += s + " ";
                LOG_MODULE_INFO(logger, MOD_ENGINE, "Available strategies: {}", avail_str);
                continue;
            }

            try {
                auto strategy = factory.create(cfg.strategy_name, cfg.symbol, cfg.params);
                engine.register_strategy(cfg.symbol, std::move(strategy));
                // 记录为 DEALER1 的 symbol
                dealer1_symbols.push_back(cfg.symbol);
                // 只添加一次（去重）
                if (std::find(valid_symbols.begin(), valid_symbols.end(), cfg.symbol) == valid_symbols.end()) {
                    valid_symbols.push_back(cfg.symbol);
                }
            } catch (const std::exception& e) {
                LOG_MODULE_ERROR(logger, MOD_ENGINE, "Failed to create strategy for {}: {}", cfg.symbol, e.what());
            }
        }
    }

    // ========================================
    // 加载 DEALER2 的策略配置（可选）
    // ========================================
    if (!engine_cfg.strategy_config_file2.empty()) {
        auto configs2 = parse_strategy_config(engine_cfg.strategy_config_file2);
        if (configs2.empty()) {
            LOG_MODULE_WARNING(logger, MOD_ENGINE, "No configurations found in {} (DEALER2)", engine_cfg.strategy_config_file2);
        } else {
            LOG_MODULE_INFO(logger, MOD_ENGINE, "Loaded {} configurations from {} (DEALER2)", configs2.size(), engine_cfg.strategy_config_file2);

            // 统计每种策略的配置数量
            std::map<std::string, int> strategy_counts;
            for (const auto& cfg : configs2) {
                strategy_counts[cfg.strategy_name]++;
            }
            for (const auto& [name, count] : strategy_counts) {
                LOG_MODULE_INFO(logger, MOD_ENGINE, "  DEALER2 - {}: {} symbols", name, count);
            }

            // 为每个配置创建策略
            for (const auto& cfg : configs2) {
                if (!factory.has_strategy(cfg.strategy_name)) {
                    LOG_MODULE_WARNING(logger, MOD_ENGINE, "Unknown strategy: {}, skipping {}", cfg.strategy_name, cfg.symbol);
                    auto available = factory.get_registered_strategies();
                    std::string avail_str;
                    for (const auto& s : available) avail_str += s + " ";
                    LOG_MODULE_INFO(logger, MOD_ENGINE, "Available strategies: {}", avail_str);
                    continue;
                }

                try {
                    auto strategy = factory.create(cfg.strategy_name, cfg.symbol, cfg.params);
                    engine.register_strategy(cfg.symbol, std::move(strategy));
                    // 记录为 DEALER2 的 symbol
                    dealer2_symbols.push_back(cfg.symbol);
                    // 只添加一次（去重）
                    if (std::find(valid_symbols.begin(), valid_symbols.end(), cfg.symbol) == valid_symbols.end()) {
                        valid_symbols.push_back(cfg.symbol);
                    }
                } catch (const std::exception& e) {
                    LOG_MODULE_ERROR(logger, MOD_ENGINE, "Failed to create strategy for {}: {}", cfg.symbol, e.what());
                }
            }
        }
    }

    if (valid_symbols.empty()) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "No valid symbols to monitor");
        return;
    }

    // [已禁用] 为所有股票添加默认策略 - 改为手动在配置文件中添加
    // // 为所有股票添加默认策略 BreakoutPriceVolumeStrategy_v2（默认禁用，需通过 ZMQ 命令启用）
    // // 注意：如果配置文件已经有该策略，则跳过以避免重复注册导致悬垂指针
    // int default_added = 0;
    // for (const auto& symbol : valid_symbols) {
    //     if (engine.has_strategy(symbol, "BreakoutPriceVolumeStrategy_v2")) {
    //         continue;  // 已有策略，跳过
    //     }
    //     try {
    //         auto default_strategy = factory.create("BreakoutPriceVolumeStrategy_v2", symbol, "");
    //         engine.register_strategy(symbol, std::move(default_strategy));
    //         default_added++;
    //     } catch (const std::exception& e) {
    //         LOG_MODULE_ERROR(logger, MOD_ENGINE, "Failed to create default strategy for {}: {}", symbol, e.what());
    //     }
    // }
    // if (default_added > 0) {
    //     LOG_MODULE_INFO(logger, MOD_ENGINE, "Added {} default BreakoutPriceVolumeStrategy_v2 instances", default_added);
    // }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Starting strategy engine with {} symbols...", valid_symbols.size());
    engine.start();

    // 创建实盘上下文（稍后在 ZMQ 客户端启动后设置）
    std::unique_ptr<LiveContext> live_ctx;

    // 初始化 ZMQ 客户端（可通过 engine.conf 中 disable_zmq=true 禁用）
    if (engine_cfg.disable_zmq) {
        LOG_MODULE_INFO(logger, MOD_ENGINE, "ZMQ client disabled via config");
    } else {
        g_zmq_client = std::make_unique<ZmqClient>(engine_cfg.zmq_endpoint, engine_cfg.zmq_endpoint2);

        // 注入策略引擎引用（支持运行时动态添加/删除策略）
        g_zmq_client->set_engine(&engine);

        if (g_zmq_client->start()) {
            LOG_MODULE_INFO(logger, MOD_ENGINE, "ZMQ client started, DEALER1: {}, DEALER2: {}",
                           engine_cfg.zmq_endpoint, engine_cfg.zmq_endpoint2);
            LOG_MODULE_INFO(logger, MOD_ENGINE, "Runtime strategy management enabled via ZMQ");

            // 创建实盘上下文并设置给所有策略
            live_ctx = std::make_unique<LiveContext>(g_zmq_client.get());
            engine.set_context_for_all_strategies(live_ctx.get());

            // 设置 symbol → dealer 映射（用于下单路由）
            for (const auto& sym : dealer1_symbols) {
                g_zmq_client->set_symbol_dealer(sym, 1);
            }
            for (const auto& sym : dealer2_symbols) {
                g_zmq_client->set_symbol_dealer(sym, 2);
            }
            LOG_MODULE_INFO(logger, MOD_ENGINE, "Set dealer mapping: {} symbols -> DEALER1, {} symbols -> DEALER2",
                           dealer1_symbols.size(), dealer2_symbols.size());
        } else {
            LOG_MODULE_WARNING(logger, MOD_ENGINE, "Failed to start ZMQ client, continuing without it");
        }
    }

    // ========================================
    // 创建持久化层 (可通过 engine.conf 中 disable_persist=true 禁用)
    // ========================================
    std::unique_ptr<PersistLayer> persist;
    if (engine_cfg.disable_persist) {
        LOG_MODULE_INFO(logger, MOD_ENGINE, "PersistLayer disabled via config");
    } else {
        persist = std::make_unique<PersistLayer>();

        // 获取当前日期
        std::string date = get_current_date();

        // 数据目录 (通过 engine.conf 配置)
        std::string data_dir = engine_cfg.persist_data_dir;

        // Writer 线程绑核 (绑定到最后一个 CPU)
        int last_cpu = static_cast<int>(std::thread::hardware_concurrency()) - 1;
        // int last_cpu = 0;

        if (!persist->init(date, data_dir, last_cpu)) {
            LOG_MODULE_ERROR(logger, MOD_ENGINE, "Failed to initialize PersistLayer");
            engine.stop();
            hft::logger::shutdown();
            com::htsc::mdc::gateway::fini_env();
            return;
        }

        LOG_MODULE_INFO(logger, MOD_ENGINE, "PersistLayer initialized: date={} dir={}", date, data_dir);
    }

    // 创建实盘数据适配器 (传入持久化层指针)
    LiveMarketAdapter adapter("market_data", &engine, persist.get());

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Connecting to market data gateway...");

    // 创建 UDP 客户端 (模仿 fastfish/src/main.cc 的 test_udp_client 实现)
    using namespace com::htsc::mdc::gateway;
    using namespace com::htsc::mdc::udp;

    // 从环境变量读取配置参数
    const char* env_user = std::getenv("FF_USER");
    const char* env_password = std::getenv("FF_PASSWORD");
    const char* env_ip = std::getenv("FF_IP");
    const char* env_port = std::getenv("FF_PORT");
    const char* env_interface_ip = std::getenv("FF_CERT_DIR");

    if (!env_user || !env_password || !env_ip || !env_port || !env_interface_ip) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "Missing required environment variables. Please set FF_USER, FF_PASSWORD, FF_IP, FF_PORT, FF_CERT_DIR");
        engine.stop();
        hft::logger::shutdown();
        return;
    }

    std::string user = env_user;
    std::string password = env_password;
    std::string ip = env_ip;
    int port = std::stoi(env_port);
    std::string interface_ip = env_interface_ip;  // UDP客户端本地接口IP

    // 创建UDP客户端
    UdpClientInterface* udp_client = ClientFactory::Instance()->CreateUdpClient();

    if (!udp_client) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "Failed to create UDP client");
        engine.stop();
        hft::logger::shutdown();
        return;
    }

    // 设置工作线程池大小
    udp_client->SetWorkPoolThreadCount(50);

    // 注册消息处理器
    udp_client->RegistHandle(&adapter);

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Logging in to gateway at {}:{}...", ip, port);

    // 登录（使用备份服务器列表）
    std::map<std::string, int> backup_list;
    backup_list.insert(std::pair<std::string, int>("168.9.65.25", 18088));
    // backup_list.insert(std::pair<std::string, int>("backup_ip_2", 18088));

    int ret = udp_client->LoginById(ip, port, user, password, backup_list);
    if (ret != 0) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "Login failed with error code: {}", ret);
        ClientFactory::Uninstance();
        engine.stop();
        hft::logger::shutdown();
        return;
    }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Login successful");

    // 订阅市场数据 - 订阅指定股票类型
    std::unique_ptr<SubscribeBySourceType> source_type(new SubscribeBySourceType());

    // 订阅上海股票的TICK、ORDER、TRANSACTION数据
    SubscribeBySourceTypeDetail* detail_shg = source_type->add_subscribebysourcetypedetail();
    SecuritySourceType* security_source_shg = new SecuritySourceType();
    security_source_shg->set_securitytype(StockType);
    security_source_shg->set_securityidsource(XSHG);
    detail_shg->set_allocated_securitysourcetypes(security_source_shg);
    detail_shg->add_marketdatatypes(MD_TICK);
    detail_shg->add_marketdatatypes(MD_ORDER);
    detail_shg->add_marketdatatypes(MD_TRANSACTION);
    // detail_shg->add_marketdatatypes(AD_ORDERBOOK_SNAPSHOT);  // OrderBook快照（备份）

    // 订阅深圳股票的TICK、ORDER、TRANSACTION数据
    SubscribeBySourceTypeDetail* detail_she = source_type->add_subscribebysourcetypedetail();
    SecuritySourceType* security_source_she = new SecuritySourceType();
    security_source_she->set_securitytype(StockType);
    security_source_she->set_securityidsource(XSHE);
    detail_she->set_allocated_securitysourcetypes(security_source_she);
    detail_she->add_marketdatatypes(MD_TICK);
    detail_she->add_marketdatatypes(MD_ORDER);
    detail_she->add_marketdatatypes(MD_TRANSACTION);
    // detail_she->add_marketdatatypes(AD_ORDERBOOK_SNAPSHOT);  // OrderBook快照（备份）

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Subscribing to market data (StockType, XSHG+XSHE)...");
    ret = udp_client->SubscribeBySourceType(interface_ip, source_type.get());
    if (ret != 0) {
        LOG_MODULE_ERROR(logger, MOD_ENGINE, "Subscribe failed with error code: {}", ret);
        ClientFactory::Uninstance();
        engine.stop();
        hft::logger::shutdown();
        return;
    }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Subscription successful");

    // 保持运行直到收到退出信号
    LOG_MODULE_INFO(logger, MOD_ENGINE, "Running... Press Ctrl+C to stop");
    while (g_running.load(std::memory_order_relaxed)) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // 优雅关闭
    LOG_MODULE_INFO(logger, MOD_ENGINE, "Received shutdown signal, cleaning up...");

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Stopping ZMQ client...");
    if (g_zmq_client) {
        g_zmq_client->stop();
        g_zmq_client.reset();
    }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Stopping PersistLayer...");
    if (persist) {
        persist->stop();
        persist.reset();
    }

    LOG_MODULE_INFO(logger, MOD_ENGINE, "Stopping strategy engine...");
    engine.stop();
    ClientFactory::Uninstance();
}

// ==========================================
// 主入口
// ==========================================
int main(int argc, char* argv[]) {
    // 注册信号处理器
    std::signal(SIGINT, signal_handler);
    std::signal(SIGTERM, signal_handler);

    // 初始化 FastFish SDK 环境 (ACE 框架)
    com::htsc::mdc::gateway::init_env();
    com::htsc::mdc::gateway::open_file_log();

    // 根据命令行参数选择模式
    std::string mode = "backtest"; // 默认回测模式

    if (argc > 1) {
        mode = argv[1];
    }

    std::cout << "Starting in " << mode << " mode..." << std::endl;

    // 统一初始化日志系统（根据模式设置日志文件名和日志等级）
    hft::logger::LogConfig log_config;
    log_config.log_dir = "logs";
    log_config.log_file = (mode == "backtest") ? "backtest.log" : "live_trading.log";
    log_config.console_output = true;
    log_config.use_rdtsc = true;
    // 回测模式使用 DEBUG 级别，生产模式使用 INFO 级别
    log_config.log_level = (mode == "backtest") ? quill::LogLevel::Debug : quill::LogLevel::Info;
    auto* logger = hft::logger::init(log_config);

    // 初始化业务日志器（交易信号等业务日志单独输出）
    hft::logger::BizLogConfig biz_config;
    biz_config.log_dir = "logs";
    biz_config.log_file = (mode == "backtest") ? "backtest_biz.log" : "live_biz.log";
    biz_config.console_output = true;
    hft::logger::init_biz(biz_config);

    // 输出 FastFish SDK 版本
    const char* dll_version = com::htsc::mdc::gateway::get_dll_version();
    LOG_MODULE_INFO(logger, MOD_ENGINE, "FastFish SDK version: {}", dll_version ? dll_version : "unknown");

    // 根据模式运行
    if (mode == "backtest") {
        run_backtest_mode(logger);
    } else if (mode == "live") {
        run_live_mode(logger);
    } else {
        std::cerr << "Unknown mode: " << mode << std::endl;
        std::cerr << "Usage: " << argv[0] << " [backtest|live]" << std::endl;
        hft::logger::shutdown();
        return 1;
    }

    // 统一关闭日志系统
    hft::logger::shutdown();

    // 清理 FastFish SDK 环境
    com::htsc::mdc::gateway::fini_env();

    return 0;
}
